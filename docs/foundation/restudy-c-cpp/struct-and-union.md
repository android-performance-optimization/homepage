# 结构和联合
本文为《C 与 指针读书笔记》，感兴趣的读者可以去看原书。

数据经常以成组的形式存在。例如，雇主必须明了每位雇员的姓名、年龄和工资。如果这些值能够存储在一起，访问起来会简单一些。但是，如果这些值的类型不同（就像现在这种情况），它们无法存储于同一个数组中。在C中，使用结构可以把不同类型的值存储在一起。

## 结构基础知识
聚合数据类型（aggregate data type）能够同时存储超过一个的单独数据。C提供了两种类型的聚合数据类型，数组和结构。数组是相同类型的元素的集合，它的每个元素是通过下标引用或指针间接访问来选择的。

结构也是一些值的集合，这些值称为它的成员 (member)，但一个结构的各个成员可能具有不同的类型。

数组元素可以通过下标访问，这只是因为数组的元素长度相同。但是，在结构中情况并非如此。由于一个结构的成员可能长度不同，所以不能使用下标来访问它们。相反，每个结构成员都有自己的名字，它们是通过名字访问的。

这个区别非常重要。结构并不是一个它自身成员的数组。和数组名不同，当一个结构变量在表达式中使用时，它并不被替换成一个指针。结构变量也无法使用下标来选择特定的成员。

结构变量属于标量类型，所以你可以像对待其他标量类型那样执行相同类型的操作。结构也可以作为传递给函数的参数，它们也可以作为返回值从函数返回，相同类型的结构变量相互之间可以赋值。你可以声明指向结构的指针，取一个结构变量的地址，也可以声明结构数组。但是，在讨论这些话题之前，我们必须知道一些更为基础的东西。

## 结构声明
在声明结构时，必须列出它包含的所有成员。这个列表包括每个成员的类型和名字。

```c
struct tag { member-list

 } variable-list
```

### 结构成员
可以在一个结构外部声明的任何变量都可以作为结构的成员。尤其是，结构成员可以是标量、数组、指针甚至是其他结构。

### 结构成员的间接访问
如果你拥有一个指向结构的指针，你该如何访问这个结构的成员呢？首先就是对指针执行间接访问操作，这使你获得这个结构。然后你使用点操作符来访问它的成员。但是，点操作符的优先级高于间接访问操作符，所以你必须在表达式中使用括号，确保间接访问首先执行。

由于这个概念有点惹人厌，所以C语言提供了一个更为方便的操作符来完成这项工作——->操作符（也称箭头操作符）。和点操作符一样，箭头操作符接受两个操作数，但左操作数必须是一个指向结构的指针 。箭头操作符对左操作数执行间接访问取得指针所指向的结构，然后和点操作符一样，根据右操作数选择一个指定的结构成员。但是，间接访问操作内建于箭头操作符中，所以我们不需要显式地执行间接访问或使用括号。

### 结构的自引用
在一个结构内部包含一个类型为该结构本身的成员是否合法呢？

当成员b是另一个完整的结构，其内部还将包含它自己的成员b时，这种类型的自引用是非法的。这第2个成员又是另一个完整的结构，它还将包括它自己的成员b。这样重复下去永无止境。这有点像永远不会终止的递归程序。

而当 b 是一个指针而不是结构时是合法的。编译器在结构的长度确定之前就已经知道指针的长度，所以这种类型的自引用是合法的。

如果你觉得一个结构内部包含一个指向该结构本身的指针有些奇怪，请记住它事实上所指向的是同一种类型的不同 结构。更加高级的数据结构，如链表和树，都是用这种技巧实现的。每个结构指向链表的下一个元素或树的下一个分枝。

### 不完整的声明
偶尔，你必须声明一些相互之间存在依赖的结构。也就是说，其中一个结构包含了另一个结构的一个或多个成员。和自引用结构一样，至少有一个结构必须在另一个结构内部以指针的形式存在。问题在于声明部分：如果每个结构都引用了其他结构的标签，哪个结构应该首先声明呢？

这个问题的解决方案是使用不完整声明(incomplete declaration)，它声明一个作为结构标签的标识符。然后，我们可以把这个标签用在不需要知道这个结构的长度的声明中，如声明指向这个结构的指针。接下来的声明把这个标签与成员列表联系在一起。

### 结构的初始化
结构的初始化方式和数组的初始化很相似。一个位于一对花括号内部、由逗号分隔的初始值列表可用于结构各个成员的初始化。这些值根据结构成员列表的顺序写出。如果初始列表的值不够，剩余的结构成员将使用缺省值进行初始化。

结构中如果包含数组或结构成员，其初始化方式类似于多维数组的初始化。一个完整的聚合类型成员的初始值列表可以嵌套于结构的初始值列表内部。

## 结构的存储分配
结构在内存中是如何实际存储的呢？前面例子的这张图似乎提示了结构内部包含了大量的未用空间。但这张图并不完全准确，编译器按照成员列表的顺序一个接一个地给每个成员分配内存。只有当存储成员时需要满足正确的边界对齐要求时，成员之间才可能出现用于填充的额外内存空间。

## 作为函数参数的结构
结构变量是一个标量，它可以用于其他标量可以使用的任何场合。因此，把结构作为参数传递给一个函数是合法的，但这种做法往往并不适宜。

如果传递给函数的是一个指向结构的指针，指针比整个结构要小得多，所以把它压到堆栈上效率能提高很多。传递指针另外需要付出的代价是我们必须在函数中使用间接访问来访问结构的成员。结构越大，把指向它的指针传递给函数的效率就越高。

在许多机器中，你可以把参数声明为寄存器变量，从而进一步提高指针传递方案的效率。在有些机器上，这种声明在函数的起始部分还需要一条额外的指令，用于把堆栈中的参数（参数先传递给堆栈）复制到寄存器，供函数使用。但是，如果函数对这个指针的间接访问次数超过两三次，那么使用这种方法所节省的时间将远远高于一条额外指令所花费的时间。

向函数传递指针的缺陷在于函数现在可以对调用程序的结构变量进行修改。如果我们不希望如此，可以在函数中使用const关键字来防止这类修改。

## 位段
关于结构，我们最后还必须提到它们实现位段(bit field)的能力。位段的声明和结构类似，但它的成员是一个或多个位的字段。这些不同长度的字段实际上存储于一个或多个整型变量中。

位段的声明和任何普通的结构成员声明相同，但有两个例外。首先，位段成员必须声明为int、signed int或unsigned int类型。其次，在成员名的后面是一个冒号和一个整数，这个整数指定该位段所占用的位的数目。

使用位段的能够把长度为奇数的数据包装在一起，节省存储空间。当程序需要使用成千上万的这类结构时，这种节省方法就会变得相当重要。另一个使用位段的理由是由于它们可以很方便地访问一个整型值的部分内容。

## 联合
和结构相比，联合（union）可以说是另一种动物了。联合的声明和结构类似，但它的行为方式却和结构不同。联合的所有成员引用的是内存中的相同位置 。当你想在不同的时刻把不同的东西存储于同一个位置时，就可以使用联合。

如果联合的各个成员具有不同的长度，联合的长度就是它最长成员的长度。

## 总结
在结构中，不同类型的值可以存储在一起。结构中的值称为成员，它们是通过名字访问的。结构变量是一个标量，可以出现在普通标量变量可以出现的任何场合。

结构的声明列出了结构包含的成员列表。不同的结构声明即使它们的成员列表相同也被认为是不同的类型。结构标签是一个名字，它与一个成员列表相关联。你可以使用结构标签在不同的声明中创建相同类型的结构变量，这样就不用每次在声明中重复成员列表。typedef也可以用于实现这个目标。

结构的成员可以是标量、数组或指针。结构也可以包含本身也是结构的成员。在不同的结构中出现同样的成员名是不会引起冲突的。你使用点操作符访问结构变量的成员。如果你拥有一个指向结构的指针，你可以使用箭头操作符访问这个结构的成员。

结构不能包含类型也是这个结构的成员，但它的成员可以是一个指向这个结构的指针。这个技巧常常用于链式数据结构中。为了声明两个结构，每个结构都包含一个指向对方的指针的成员，我们需要使用不完整的声明来定义一个结构标签名。结构变量可以用一个由花括号包围的值列表进行初始化。这些值的类型必须适合它所初始化的那些成员。

编译器为一个结构变量的成员分配内存时要满足它们的边界对齐要求。在实现结构存储的边界对齐时，可能会浪费一部分内存空间。根据边界对齐要求降序排列结构成员可以最大限度地减少结构存储中浪费的内存空间。sizeof返回的值包含了结构中浪费的内存空间。

结构可以作为参数传递给函数，也可以作为返回值从函数返回。但是，向函数传递一个指向结构的指针往往效率更高。在结构指针参数的声明中可以加上const关键字防止函数修改指针所指向的结构。

位段是结构的一种，但它的成员长度以位为单位指定。位段声明在本质上是不可移植的，因为它涉及许多与实现有关的因素。但是，位段允许你把长度为奇数的值包装在一起以节省存储空间。源代码如果需要访问一个值内部任意的一些位，使用位段比较简便。

一个联合的所有成员都存储于同一个内存位置。通过访问不同类型的联合成员，内存中相同的位组合可以被解释为不同的东西。联合在实现变体记录时很有用，但程序员必须负责确认实际存储的是哪个变体并选择正确的联合成员以便访问数据。联合变量也可以进行初始化，但初始值必须与联合第1个成员的类型匹配。

## 编程练习
### 练习 1
当你拨打长途电话时，电话公司所保存的信息包括你拨打电话的日期和时间。它还包括三个电话号码：你使用的那个电话、你呼叫的那个电话以及你付账的那个电话。这些电话号码的每一个都由三个部分组成：区号、交换台和站号码。请为这些记账信息编写一个结构声明。

```c
#include <stdio.h>

// 定义电话号码的结构
typedef struct {
    int areaCode;    // 区号
    int exchange;    // 交换台
    int station;     // 站号码
} PhoneNumber;

// 定义记账信息的结构
typedef struct {
    char callDate[11];  // 电话拨打的日期，格式"YYYY-MM-DD"，包括结束符'\0'需要11个字符
    char callTime[6];   // 电话拨打的时间，格式"HH:MM"，包括结束符'\0'需要6个字符
    PhoneNumber usingPhone;  // 使用的电话
    PhoneNumber calledPhone; // 呼叫的电话
    PhoneNumber billingPhone; // 付账的电话
} CallBillingInfo;

int main() {
    // 示例：创建一个CallBillingInfo实例并初始化
    CallBillingInfo callInfo = {
        "2023-04-01", // 电话拨打日期
        "15:30",      // 电话拨打时间
        {123, 456, 7890}, // 使用的电话号码（区号、交换台、站号码）
        {321, 654, 0987}, // 呼叫的电话号码
        {111, 222, 3333}  // 付账的电话号码
    };

    // 输出某些信息进行验证
    printf("Call Date: %s\n", callInfo.callDate);
    printf("Call Time: %s\n", callInfo.callTime);
    printf("Using Phone: (%d) %d-%d\n", 
            callInfo.usingPhone.areaCode, 
            callInfo.usingPhone.exchange, 
            callInfo.usingPhone.station);
    return 0;
}
```

















